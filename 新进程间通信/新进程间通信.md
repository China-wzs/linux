# 1. 管道 （PIPE）
管道实际是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。

管道的特点：

 1. 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；
 2. 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。 比如fork或exec创建的新进程，在使用exec创建新进程时，需要将管道的文件描述符作为参数传递给exec创建的新进程。当父进程与使用fork创建的子进程直接通信时，发送数据的进程关闭读端，接受数据的进程关闭写端。
 3.  单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。
 4. 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。
 
**管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。** 管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。**当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。**

管道只能在本地计算机中使用，而不可用于网络间的通信。

使用格式为：

```
#include<unistd.h>
int  pipe(int fd[2]);
```
功能： 创建一个简单的管道，若成功则为数组fd分配两个文件描述符，其中fd[0] 用于读取管道，fd[1]用于写入管道。
返回：成功返回0，失败返回-1；
（1）管道通信是单向的，并且遵守先进先出的原则，即先写入的数据先读出。
（2）管道是一个无结构，无固定大小的字节流。
（3） 管道把一个进程的标准输出和另一个进程的标准输入连接在一起。数据读出后就意味着从管道中移走了，消失了。其它的进程都不能   
再读到这些数据。就像我们平常见到的管子水流走了就没有了。 这点很重要！！
（4） pipe这种管道用于两个有亲缘关系的进程之间。eg:父子进程......
![在这里插入图片描述](https://img-blog.csdnimg.cn/e1b3ec524b364985a82928c7a070cf76.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzNTU4OA==,size_16,color_FFFFFF,t_70)
1. 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。

2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。

3. 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。

```c
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h>
void sys_err(const char *str)
{
    perror(str);
    exit(1);
}
int main(void)
{
    pid_t pid;
    char buf[1024];
    int fd[2];
    char *p = "test for pipe\n";
    
   if (pipe(fd) == -1)
       sys_err("pipe");
   pid = fork();
   if (pid < 0) {
       sys_err("fork err");
   } else if (pid == 0) {
        close(fd[1]);
        int len = read(fd[0], buf, sizeof(buf));
        write(STDOUT_FILENO, buf, len);
        close(fd[0]);
   } else {
       close(fd[0]);
       write(fd[1], p, strlen(p));
       wait(NULL);
       close(fd[1]);
   }
    
    return 0;
}
```
# 2. 命名管道（FIFO）
也叫有名管道、FIFO 文件。允许没有亲缘关系的进程间通信。 
**以 FIFO 的文件形式存在于文件系统中**，这样，即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，**因此，通过 FIFO 不相关的进程也能交换数据。**

命名管道（FIFO)和无名管道（pipe）有一些特点是相同的，不一样的地方在于:

> 1、FIFO 在文件系统中作为一个特殊的文件而存在，但 FIFO 中的内容却存放在内存中。
2、当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。
3、FIFO 有名字，不相关的进程可以通过打开命名管道进行通信。

命名管道的创建
所需头文件：

```c
#include <sys/types.h>
#include <sys/stat.h>
```
int mkfifo( const char *pathname, mode_t mode);
功能：
命名管道的创建。
参数：
> pathname: 普通的路径名，也就是创建后 FIFO 的名字。 mode: 文件的权限，与打开普通文件的 open() 函数中的
> mode 参数相同，相关说明请点此链接。 返回值：

成功：0
失败：如果文件已经存在，则会出错且返回 -1。

```cpp
1. #include <stdio.h>  
2. #include <sys/types.h>  
3. #include <sys/stat.h>  
4.   
5. int main(int argc, char *argv[])  
6. {  
7.     int ret;  
8.       
9.     ret = mkfifo("my_fifo", 0666); // 创建命名管道  
10.     if(ret != 0){   // 出错  
11.         perror("mkfifo");  
12.     }  
13.       
14.     return 0;  
15. }  
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/38fcdcc71bc64950bbf467eb33c5ea9e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzNTU4OA==,size_16,color_FFFFFF,t_70)
后期的操作，把这个命名管道当做普通文件一样进行操作：open()、write()、read()、close()。但是，和无名管道一样，操作命名管道肯定要考虑默认情况下其阻塞特性。

细看：
[https://blog.csdn.net/lianghe_work/article/details/47722175](https://blog.csdn.net/lianghe_work/article/details/47722175)

> 下面验证的是默认情况下的特点，即 open() 的时候没有指定非阻塞标志( O_NONBLOCK )。 
> 
> 1） open() 以只读方式打开 FIFO 时，要阻塞到某个进程为写而打开此 FIFO open() 以只写方式打开 FIFO
> 时，要阻塞到某个进程为读而打开此 FIFO。 简单一句话，只读等着只写，只写等着只读，只有两个都执行到，才会往下执行。 
> 2）假如 FIFO 里没有数据，调用 read() 函数从 FIFO 里读数据时 read() 也会阻塞。这个特点和无名管道是一样的。
> 3）通信过程中若写进程先退出了，就算命名管道里没有数据，调用 read() 函数从 FIFO 里读数据时不阻塞；若写进程又重新运行，则调用
> read() 函数从 FIFO 里读数据时又恢复阻塞。 
> 4）通信过程中，读进程退出后，写进程向命名管道内写数据时，写进程也会（收到SIGPIPE 信号）退出。 5）调用 write() 函数向 FIFO 里写数据，当缓冲区已满时 write() 也会阻塞。 
> 4和5这两个特点和无名管道是一样的，这里不再验证，详情请看《无名管道》。

#### 命名管道非阻塞标志操作
命名管道可以以非阻塞标志（O_NONBLOCK）方式打开：
非阻塞标志（O_NONBLOCK）打开的命名管道有以下特点：

 1. 先以只读方式打开，如果没有进程已经为写而打开一个 FIFO, 只读 open() 成功，并且 open() 不阻塞。
 2. 先以只写方式打开，如果没有进程已经为读而打开一个 FIFO，只写 open() 将出错返回 -1。
 3. read()、write() 读写命名管道中读数据时不阻塞。

## 3. 信号 （signal）
